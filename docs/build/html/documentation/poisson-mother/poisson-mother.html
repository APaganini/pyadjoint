
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Optimal control of the Poisson equation</title>
    
    <link rel="stylesheet" href="../../_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2017.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="../../_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="../../_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: false,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31806773-1']);
  _gaq.push(['_setDomainName', 'dolfin-adjoint.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- Load the flex slider library -->
<link rel="stylesheet" href="_static/flexslider/flexslider.css" type="text/css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
<script src="_static/flexslider/jquery.flexslider.js"></script>

<script type="text/javascript" charset="utf-8">
  $(window).load(function() {
  $('.flexslider').flexslider();
  });
</script>

<!-- Load the code highlight library -->
<link rel="stylesheet" href="_static/highlight/styles/zenburn.css">
<script src="_static/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="shortcut icon" href="../../_static/icon.ico" />


  </head>
  <body>
<div class="wrapper">
  <a href="../../"><img src="../../_static/banner.png" width="900px" alt="dolfin-adjoint Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="../../about/index.html" title="Find out more about dolfin-adjoint">About</a></li>
          <li class="page_item"><a href="../../features/index.html" title="Features of dolfin-adjoint">Features</a></li>
          <li class="page_item"><a href="../index.html" title="Learn how to use dolfin-adjoint">Documentation</a></li>
          <li class="page_item"><a href="../../download/index.html" title="Obtain the dolfin-adjoint code">Download</a></li>
          <li class="page_item"><a href="../../citing/index.html" title="Learn how to cite the dolfin-adjoint project">Citing</a></li>
          <li class="page_item"><a href="../../support/index.html" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="optimal-control-of-the-poisson-equation">
<h1>Optimal control of the Poisson equation<a class="headerlink" href="#optimal-control-of-the-poisson-equation" title="Permalink to this headline">¶</a></h1>
<p>This demo solves the <cite>mother problem</cite> of PDE-constrained
optimisation: the optimal control of the Poisson equation.
Physically, this problem can the interpreted as finding the best
heating/cooling of a cooktop to achieve a desired temperature
profile.</p>
<p>This example introduces the basics of how to solve optimisation
problems with dolfin-adjoint.</p>
<div class="section" id="problem-definition">
<h2>Problem definition<a class="headerlink" href="#problem-definition" title="Permalink to this headline">¶</a></h2>
<p>Mathematically, the problem is to minimise the following tracking-type
functional</p>
<div class="math">
\[\frac{1}{2} \int_{\Omega} (u - d)^2 \textrm{d}x
        + \frac{\alpha}{2} \int_{\Omega} f^2 \textrm{d}s\]</div>
<p>subject to the Poisson equation with Dirichlet boundary conditions</p>
<div class="math">
\[\begin{split}-\kappa \Delta u &amp;= f  \qquad \mathrm{in} \ \Omega           \\
                  u &amp;= 0  \qquad \mathrm{on} \ \partial \Omega  \\
                  a &amp; \le f \le b\end{split}\]</div>
<p>where <span class="math">\(\Omega\)</span> is the domain of interest (here the unit square),
<span class="math">\(u: \Omega \to \mathbb R\)</span> is the unkown temperature, <span class="math">\(\kappa
\in \mathbb R\)</span> is the thermal diffusivity (here: <span class="math">\(\kappa = 1\)</span>),
<span class="math">\(f: \Omega \to \mathbb R\)</span> is the unknown control function acting
as source term (<span class="math">\(f(x) &gt; 0\)</span> corresponds to heating and
<span class="math">\(f(x) &lt; 0\)</span> corresponds to cooling), <span class="math">\(d: \Omega \to \mathbb
R\)</span> is the given desired temperature profile, <span class="math">\(\alpha \in [0,
\infty)\)</span> is a Tikhonov regularisation parameter, and <span class="math">\(a, b:
\Omega \to \mathbb R\)</span> are lower and upper bounds for the control
function.</p>
<p>It can be shown that this problem is well-posed and has a unique
solution, see <a class="reference internal" href="#troltzsch2010" id="id1">[1E-Troltzsch10]</a> or section 1.5 of
<a class="reference internal" href="#hinze2009" id="id2">[1E-HPUU09]</a>.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>We start our implementation by importing the <code class="xref py py-mod docutils literal"><span class="pre">dolfin</span></code> and
<code class="xref py py-mod docutils literal"><span class="pre">dolfin_adjoint</span></code> modules:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">dolfin_adjoint</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we import the Python interface to Moola. Moola is a collection
of optimisation solvers specifically designed for PDE-constrained
optimisation problems. If Moola is not yet available on your system,
it is <a class="reference internal" href="../../download/index.html"><span class="doc">easy to install</span></a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">moola</span>
</pre></div>
</div>
<p>Next we create a regular mesh of the unit square. Some optimisation
algorithms suffer from bad performance when the mesh is non-uniform
(i.e. when the mesh is partially refined). To demonstrate that Moola
does not have this issue, we refine the mesh near the center of the
domain:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="n">cf</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
<span class="n">subdomain</span> <span class="o">=</span> <span class="n">CompiledSubDomain</span><span class="p">(</span><span class="s1">&#39;std::abs(x[0]-0.5) &lt; 0.25 &amp;&amp; std::abs(x[1]-0.5) &lt; 0.25&#39;</span><span class="p">)</span>
<span class="n">subdomain</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">refine</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cf</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting mesh looks like this:</p>
<a class="reference internal image-reference" href="../../_images/mesh.png"><img alt="../../_images/mesh.png" class="align-center" src="../../_images/mesh.png" style="width: 401.5px; height: 402.5px;" /></a>
<p>Then we define the discrete function spaces and create functions for
the temperature and the control function.</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;x[0]+x[1]&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">W</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Control&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;State&#39;</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>The optimisation algorithm will use the value of the control
function <span class="math">\(f\)</span> as an initial guess for the optimisation.  A
zero-initial guess for the control appears to be too simple: for
example L-BFGS finds the optimal control with just two iterations.
To make it more interesting, we chose a non-zero initial guess
instead.</p>
<p>Next we define the weak formulation of the Poisson problem and solve
it.</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;on_boundary&quot;</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>By doing so, <cite>dolfin-adjoint</cite> automatically records the details of
each PDE solve (also called a tape). This tape will be used by the
optimisation algorithm to repeatedly solve the forward and adjoint
problems for varying control inputs.</p>
<p>Before we can start the optimisation, we need to specify the control
variable and define the functional of interest.  For this example we
use <span class="math">\(d(x, y) = \frac{1}{2\pi^2}\sin(\pi x)\sin(\pi y)\)</span> as the
desired temperature profile, and choose <span class="math">\(f\)</span> as the control
variable.</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;sin(pi*x[0])*sin(pi*x[1])&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;d*w&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">alpha</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">Functional</span><span class="p">((</span><span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="o">-</span><span class="n">d</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
<span class="n">control</span> <span class="o">=</span> <span class="n">Control</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to formulate the so-called reduced optimisation
problem. The idea is that the solution <span class="math">\(u\)</span> can be considered
as a function of <span class="math">\(f\)</span>: given a value for <span class="math">\(f\)</span>, we can
solve the Poisson equation to obtain the associated solution
<span class="math">\(u\)</span>. By denoting this solution function as <span class="math">\(u(f)\)</span>, we
can write the original optimisation problem as a reduced problem:</p>
<div class="math">
\[\min_f \frac{1}{2} \int_{\Omega} (u(f) - d)^2 \textrm{d}x + \frac{\alpha}{2} \int_{\Omega} f^2 \textrm{d}s\]</div>
<p>Note that no PDE-constraint is required anymore, since it is
implicitly contained in the solution function.</p>
<p><cite>dolfin-adjoint</cite> can automatically reduce the optimisation problem
by creating a <code class="xref py py-class docutils literal"><span class="pre">ReducedFunctional</span></code> object.  This object
solves the forward PDE using dolfin-adjoint’s tape each time the
functional is to be evaluated, and derives and solves the adjoint
equation each time the functional gradient is to be evaluated.</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">rf</span> <span class="o">=</span> <span class="n">ReducedFunctional</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">control</span><span class="p">)</span>
</pre></div>
</div>
<p>Now that all the ingredients are in place, we can perform the
optimisation.</p>
<p>Next we use <code class="xref py py-class docutils literal"><span class="pre">MoolaOptimizationProblem</span></code> to generate a problem that
is compatible with the Moola optimisation framework.  Then, we
wrap the control function into a Moola object, and create a
<code class="xref py py-meth docutils literal"><span class="pre">NewtonCG()</span></code> solver for solving the optimisation problem:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">problem</span> <span class="o">=</span> <span class="n">MoolaOptimizationProblem</span><span class="p">(</span><span class="n">rf</span><span class="p">)</span>
<span class="n">f_moola</span> <span class="o">=</span> <span class="n">moola</span><span class="o">.</span><span class="n">DolfinPrimalVector</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">moola</span><span class="o">.</span><span class="n">NewtonCG</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">f_moola</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span>
                                                   <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
                                                   <span class="s1">&#39;display&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                                                   <span class="s1">&#39;ncg_hesstol&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
</pre></div>
</div>
<p>Alternatively an L-BFGS solver could initialised by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="n">moola</span><span class="o">.</span><span class="n">BFGS</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">f_moola</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;jtol&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                               <span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mf">1e-9</span><span class="p">,</span>
                                               <span class="s1">&#39;Hinit&#39;</span><span class="p">:</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span>
                                               <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
                                               <span class="s1">&#39;mem_lim&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>
</pre></div>
</div>
<p>Then we can solve the optimisation problem, extract the optimal
control and plot it:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="n">f_opt</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;control&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

<span class="n">plot</span><span class="p">(</span><span class="n">f_opt</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;f_opt&quot;</span><span class="p">)</span>

<span class="c1"># Define the expressions of the analytical solution</span>
<span class="n">f_analytic</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;1/(1+alpha*4*pow(pi, 4))*w&quot;</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">u_analytic</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;1/(2*pow(pi, 2))*f&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f_analytic</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then compute the errors between numerical and analytical
solutions.</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">f_opt</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">control_error</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">f_analytic</span><span class="p">,</span> <span class="n">f_opt</span><span class="p">)</span>
<span class="n">state_error</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_analytic</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;h(min):           </span><span class="si">%e</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">mesh</span><span class="o">.</span><span class="n">hmin</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in state:   </span><span class="si">%e</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">state_error</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in control: </span><span class="si">%e</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">control_error</span><span class="p">)</span>
</pre></div>
</div>
<p>The example code can be found in <code class="docutils literal"><span class="pre">examples/poisson-mother</span></code> in the
<code class="docutils literal"><span class="pre">dolfin-adjoint</span></code> source tree, and executed as follows:</p>
<div class="highlight-bash"><div class="highlight"><pre>$ python poisson-mother.py
...
</pre></div>
</div>
</div>
<div class="section" id="convergence-order-and-mesh-independence">
<h2>Convergence order and mesh independence<a class="headerlink" href="#convergence-order-and-mesh-independence" title="Permalink to this headline">¶</a></h2>
<p>It is highly desirable that the optimisation algorithm achieve mesh
independence: i.e., that the required number of optimisation
iterations is independent of the mesh resolution.  Achieving mesh
independence requires paying careful attention to the inner product
structure of the function space in which the solution is sought.</p>
<p>For our desired temperature, the analytical solutions of the optimisation
problem is:</p>
<div class="math">
\[\begin{split}f_{\textrm{analytic}} &amp;= \frac{1}{1+4\alpha \pi^4}\sin(\pi x) \sin(\pi y) \\
u_{\textrm{analytic}} &amp;= \frac{1}{2\pi^2}f_{\textrm{analytic}}\end{split}\]</div>
<p>The following numerical experiments solve the optimisation problem
for a sequence of meshes with increasing resolutions and record the
numerical error and the required number of optimisation iterations.
A regularisation coefficient of <span class="math">\(\alpha = 10^{-6}\)</span> was used, and
the optimisation was stopped when the <span class="math">\(L_2\)</span> norm of the
reduced functional gradient dropped below <span class="math">\(10^{-9}\)</span>.</p>
<div class="section" id="moola-newton-cg">
<h3>Moola Newton-CG<a class="headerlink" href="#moola-newton-cg" title="Permalink to this headline">¶</a></h3>
<p>The Moola Newton-CG algorithm implements an inexact Newton method.
Hence, even though the optimality system of our problem is linear,
we can not expect the algorithm to converge in a single iteration
(however, we could it enforce that by explicitly setting the
relative tolerance of the CG algorithm to zero).</p>
<p>Running the Newton-CG algorithm for the different meshes yielded:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="26%" />
<col width="21%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Mesh element size</th>
<th class="head">Newton iterations</th>
<th class="head">CG iterations</th>
<th class="head">Error in control</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>6.250e-02</td>
<td>3</td>
<td>54</td>
<td>3.83e-02</td>
</tr>
<tr class="row-odd"><td>3.125e-02</td>
<td>3</td>
<td>59</td>
<td>1.69e-02</td>
</tr>
<tr class="row-even"><td>1.563e-02</td>
<td>3</td>
<td>57</td>
<td>8.05e-03</td>
</tr>
<tr class="row-odd"><td>7.813e-03</td>
<td>3</td>
<td>58</td>
<td>3.97e-03</td>
</tr>
</tbody>
</table>
<p>Here CG iterations denotes the total number of CG iterations during
the optimisation. Mesh independent convergence can be observed, both
in the Newton and CG iterations.</p>
<p>From our choice of discretisation (<span class="math">\(DG_0\)</span> for <span class="math">\(f\)</span>), we
expect a 1st order of convergence for the control variable.  Indeed,
the error column in the numerical experiments confirm that this rate
is obtained in practice.</p>
</div>
<div class="section" id="moola-l-bfgs">
<h3>Moola L-BFGS<a class="headerlink" href="#moola-l-bfgs" title="Permalink to this headline">¶</a></h3>
<p>The L-BFGS algorithm in Moola implements the limited memory quasi
Newton method with Broyden-Fletcher-Goldfarb-Shanno updates.  For
the numerical experiments, the set of the memory history was set to
10.</p>
<p>The numerical results yield:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="33%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Mesh element size</th>
<th class="head">L-BFGS iterations</th>
<th class="head">Error in control</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>6.250e-02</td>
<td>53</td>
<td>3.83e-02</td>
</tr>
<tr class="row-odd"><td>3.125e-02</td>
<td>50</td>
<td>1.69e-02</td>
</tr>
<tr class="row-even"><td>1.563e-02</td>
<td>57</td>
<td>8.05e-03</td>
</tr>
<tr class="row-odd"><td>7.813e-03</td>
<td>56</td>
<td>3.97e-03</td>
</tr>
</tbody>
</table>
<p>Again a mesh-independent convergence and a 1st order convergence of
the control can be observed.</p>
<p id="bibtex-bibliography-documentation/poisson-mother/poisson-mother-0"><table class="docutils citation" frame="void" id="hinze2009" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1E-HPUU09]</a></td><td>M.&nbsp;Hinze, R.&nbsp;Pinnau, M.&nbsp;Ulbrich, and S.&nbsp;Ulbrich. <em>Optimization with PDE constraints</em>. Volume&nbsp;23 of Mathematical Modelling: Theory and Applications. Springer, 2009. ISBN 978-1-4020-8838-4.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="troltzsch2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1E-Troltzsch10]</a></td><td>F.&nbsp;Tröltzsch. <em>Optimal control of partial differential equations: Theory, methods and applications</em>. Volume 112 of Graduate Studies in Mathematics. AMS, 2010. ISBN 978-0821849040.</td></tr>
</tbody>
</table>
</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Sebastian Mitusch.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>