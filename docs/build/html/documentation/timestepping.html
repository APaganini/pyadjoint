
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A library for writing transient models</title>
    
    <link rel="stylesheet" href="../_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2017.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="../_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="../_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: false,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31806773-1']);
  _gaq.push(['_setDomainName', 'dolfin-adjoint.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- Load the flex slider library -->
<link rel="stylesheet" href="_static/flexslider/flexslider.css" type="text/css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
<script src="_static/flexslider/jquery.flexslider.js"></script>

<script type="text/javascript" charset="utf-8">
  $(window).load(function() {
  $('.flexslider').flexslider();
  });
</script>

<!-- Load the code highlight library -->
<link rel="stylesheet" href="_static/highlight/styles/zenburn.css">
<script src="_static/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="shortcut icon" href="../_static/icon.ico" />


  </head>
  <body>
<div class="wrapper">
  <a href="../"><img src="../_static/banner.png" width="900px" alt="dolfin-adjoint Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="../about/index.html" title="Find out more about dolfin-adjoint">About</a></li>
          <li class="page_item"><a href="../features/index.html" title="Features of dolfin-adjoint">Features</a></li>
          <li class="page_item"><a href="index.html" title="Learn how to use dolfin-adjoint">Documentation</a></li>
          <li class="page_item"><a href="../download/index.html" title="Obtain the dolfin-adjoint code">Download</a></li>
          <li class="page_item"><a href="../citing/index.html" title="Learn how to cite the dolfin-adjoint project">Citing</a></li>
          <li class="page_item"><a href="../support/index.html" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="a-library-for-writing-transient-models">
<span id="timestepping"></span><h1>A library for writing transient models<a class="headerlink" href="#a-library-for-writing-transient-models" title="Permalink to this headline">¶</a></h1>
<p>In this section, the experimental timestepping library is described.
The timestepping library offers <strong>an alternative way of writing forward models</strong>
that enables extra optimisations in the adjoint run. <strong>dolfin-adjoint handles
time-dependent models without the use of this library.</strong></p>
<p>Transient models typically consist of a known repeating model “timestep”. This
leads to a repeating model structure, and this structure may be exploited to
increase model performance. In particular, if the structure of the transient
model is known, it is possible for static data to be pre-computed and cached
before timestepping the model itself.</p>
<p>The dolfin-adjoint source code includes an additional <strong>experimental</strong> library,
known as the timestepping library, which enables such optimisations to be
performed. This library may be used on its own or in combination with the
dolfin-adjoint library. The library source code can be found in the
timestepping/ directory of the dolfin-adjoint source tree, and more complete
documentation can be found in the timestepping/manual/ directory.</p>
<div class="section" id="the-timestepping-python-module">
<h2>The timestepping Python module<a class="headerlink" href="#the-timestepping-python-module" title="Permalink to this headline">¶</a></h2>
<p>The timestepping library can be accessed via:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">timestepping</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This provides additional functionality enabling a transient model to be
described. For example, the following yields a very simple model for the
diffusion equation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">timestepping</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Define a simple structured mesh on the unit interval</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitIntervalMesh</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># P1 function space</span>
<span class="n">space</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Model parameters and boundary conditions</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">StaticConstant</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">bc1</span> <span class="o">=</span> <span class="n">StaticDirichletBC</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
  <span class="s2">&quot;on_boundary &amp;&amp; near(x[0], 0.0)&quot;</span><span class="p">)</span>
<span class="n">bc2</span> <span class="o">=</span> <span class="n">StaticDirichletBC</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
  <span class="s2">&quot;on_boundary &amp;&amp; near(x[0], 1.0)&quot;</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span><span class="p">]</span>
<span class="n">nu</span> <span class="o">=</span> <span class="n">StaticConstant</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># Define time levels</span>
<span class="n">levels</span> <span class="o">=</span> <span class="n">TimeLevels</span><span class="p">(</span><span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cycle_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span>
<span class="c1"># A time dependent function</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>

<span class="c1"># Initialise a TimeSystem</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">TimeSystem</span><span class="p">()</span>

<span class="c1"># Add an initial assignment</span>
<span class="n">u_ic</span> <span class="o">=</span> <span class="n">StaticFunction</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;u_ic&quot;</span><span class="p">)</span>
<span class="n">u_ic</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">bc1</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">u_ic</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>
<span class="n">system</span><span class="o">.</span><span class="n">add_solve</span><span class="p">(</span><span class="n">u_ic</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># Register a simple diffusion equation, discretised in time</span>
<span class="c1"># using forward Euler</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">add_solve</span><span class="p">(</span>
  <span class="n">inner</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">==</span>
    <span class="o">-</span><span class="n">nu</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">test</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span> <span class="o">*</span> <span class="n">dx</span><span class="p">,</span>
  <span class="n">u</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bcs</span><span class="p">,</span>
  <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;linear_solver&quot;</span><span class="p">:</span><span class="s2">&quot;lu&quot;</span><span class="p">})</span>

<span class="c1"># Assemble the TimeSystem</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>

<span class="c1"># Timestep the model</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0e-9</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
  <span class="n">system</span><span class="o">.</span><span class="n">timestep</span><span class="p">()</span>
  <span class="n">t</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="c1"># Finalise</span>
<span class="n">system</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>
</pre></div>
</div>
<p>The timestepping library can derive discrete adjoint models and perform
derivative calculations. Time discretisation specific optimisations are
applied to the adjoint model. The following modification to the above example
performs such a calculation, and verifies the computed derivative via a
Taylor remainder test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c1"># Assemble the TimeSystem, enabling the adjoint. Set the</span>
<span class="c1"># functional to be equal to spatial integral of the final u.</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">adjoint</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">functional</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span>

<span class="c1"># Timestep the model</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0e-9</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
  <span class="n">system</span><span class="o">.</span><span class="n">timestep</span><span class="p">()</span>
  <span class="n">t</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="c1"># Finalise</span>
<span class="n">system</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>

<span class="c1"># Perform a total derivative calculation</span>
<span class="n">dJ</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">compute_gradient</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>

<span class="c1"># Verify the stored forward model data</span>
<span class="n">system</span><span class="o">.</span><span class="n">verify_checkpoints</span><span class="p">()</span>
<span class="c1"># Verify the computed derivative using a Taylor remainder</span>
<span class="c1"># convergence test</span>
<span class="n">orders</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">taylor_test</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">dJ</span><span class="p">)</span>
<span class="c1"># Check the convergence order</span>
<span class="k">assert</span><span class="p">((</span><span class="n">orders</span> <span class="o">&gt;</span> <span class="mf">1.99</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="the-dolfin-adjoint-timestepping-python-module">
<h2>The dolfin_adjoint_timestepping Python module<a class="headerlink" href="#the-dolfin-adjoint-timestepping-python-module" title="Permalink to this headline">¶</a></h2>
<p>The functionality of the timestepping and dolfin-adjoint libraries can be
combined via:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">dolfin_adjoint_timestepping</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>The following example constructs a very simple model for the diffusion equation
using the timestepping library. dolfin-adjoint is then used to derive a
discrete adjoint model, perform a total derivative calculation, and verify the
computed derivative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">dolfin_adjoint_timestepping</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1">### Stage 1: Configure and execute the forward model using</span>
<span class="c1">###          functionality provided by the timestepping library</span>

<span class="c1"># Define a simple structured mesh on the unit interval</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitIntervalMesh</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># P1 function space</span>
<span class="n">space</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Model parameters and boundary conditions</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">StaticConstant</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">bc1</span> <span class="o">=</span> <span class="n">StaticDirichletBC</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
  <span class="s2">&quot;on_boundary &amp;&amp; near(x[0], 0.0)&quot;</span><span class="p">)</span>
<span class="n">bc2</span> <span class="o">=</span> <span class="n">StaticDirichletBC</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
  <span class="s2">&quot;on_boundary &amp;&amp; near(x[0], 1.0)&quot;</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc1</span><span class="p">,</span> <span class="n">bc2</span><span class="p">]</span>
<span class="n">nu</span> <span class="o">=</span> <span class="n">StaticConstant</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># Define time levels</span>
<span class="n">levels</span> <span class="o">=</span> <span class="n">TimeLevels</span><span class="p">(</span><span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cycle_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span>
<span class="c1"># A time dependent function</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>

<span class="c1"># Initialise a TimeSystem</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">TimeSystem</span><span class="p">()</span>

<span class="c1"># Add an initial assignment</span>
<span class="n">u_ic</span> <span class="o">=</span> <span class="n">StaticFunction</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;u_ic&quot;</span><span class="p">)</span>
<span class="n">u_ic</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">bc1</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">u_ic</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>
<span class="n">system</span><span class="o">.</span><span class="n">add_solve</span><span class="p">(</span><span class="n">u_ic</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># Register a simple diffusion equation, discretised in time</span>
<span class="c1"># using forward Euler</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">add_solve</span><span class="p">(</span>
  <span class="n">inner</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">==</span>
    <span class="o">-</span><span class="n">nu</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">test</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span> <span class="o">*</span> <span class="n">dx</span><span class="p">,</span>
  <span class="n">u</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bcs</span><span class="p">,</span>
  <span class="n">solver_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;linear_solver&quot;</span><span class="p">:</span><span class="s2">&quot;lu&quot;</span><span class="p">})</span>

<span class="c1"># Assemble the TimeSystem</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="n">initialise</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>

<span class="c1"># Run the forward model. The model execution is wrapped by a</span>
<span class="c1"># function to enable adjoint verification using the</span>
<span class="c1"># dolfin-adjoint taylor_test function.</span>
<span class="k">def</span> <span class="nf">run_forward</span><span class="p">():</span>
  <span class="n">system</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
  <span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">while</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1.0e-9</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
    <span class="n">system</span><span class="o">.</span><span class="n">timestep</span><span class="p">()</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
  <span class="n">system</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>
  <span class="k">return</span>
<span class="n">run_forward</span><span class="p">()</span>

<span class="c1">### Stage 2: Access features provided by the dolfin-adjoint library</span>

<span class="c1"># Disable annotation of model equations by dolfin-adjoint</span>
<span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;adjoint&quot;</span><span class="p">][</span><span class="s2">&quot;stop_annotating&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c1"># Define a functional equal to spatial integral of the final u</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span>
<span class="c1"># Perform a total derivative calculation</span>
<span class="n">J_da</span> <span class="o">=</span> <span class="n">Functional</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="n">dolfin_adjoint</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="n">FINISH_TIME</span><span class="p">])</span>
<span class="n">nu_da</span> <span class="o">=</span> <span class="n">Control</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
<span class="n">dJ</span> <span class="o">=</span> <span class="n">compute_gradient</span><span class="p">(</span><span class="n">J_da</span><span class="p">,</span> <span class="n">nu_da</span><span class="p">)</span>

<span class="c1"># Verify the computed derivative using a Taylor remainder</span>
<span class="c1"># convergence test</span>
<span class="k">def</span> <span class="nf">J_p</span><span class="p">(</span><span class="n">nu_p</span><span class="p">):</span>
  <span class="n">nu</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">nu_p</span><span class="p">)</span>
  <span class="n">system</span><span class="o">.</span><span class="n">reassemble</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
  <span class="n">run_forward</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">assemble</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
<span class="n">order</span> <span class="o">=</span> <span class="n">taylor_test</span><span class="p">(</span><span class="n">J_p</span><span class="p">,</span> <span class="n">nu_da</span><span class="p">,</span> <span class="n">assemble</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">dJ</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="mf">1.0e-6</span><span class="p">)</span>
<span class="c1"># Check the convergence order</span>
<span class="k">assert</span><span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mf">1.99</span><span class="p">)</span>
</pre></div>
</div>
<p>The native timestepping Python module can often yield faster adjoint models than
the dolfin_adjoint_timestepping module, but is much less feature complete.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Sebastian Mitusch.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>