
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Adding Custom Functions</title>
    <link rel="stylesheet" href="../_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2017.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="../_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="../_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: false,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31806773-1']);
  _gaq.push(['_setDomainName', 'dolfin-adjoint.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- Load the flex slider library -->
<link rel="stylesheet" href="_static/flexslider/flexslider.css" type="text/css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
<script src="_static/flexslider/jquery.flexslider.js"></script>

<script type="text/javascript" charset="utf-8">
  $(window).load(function() {
  $('.flexslider').flexslider();
  });
</script>

<!-- Load the code highlight library -->
<link rel="stylesheet" href="_static/highlight/styles/zenburn.css">
<script src="_static/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="shortcut icon" href="../_static/icon.ico" />


  </head>
  <body>
<div class="wrapper">
  <a href="../"><img src="../_static/banner.png" width="900px" alt="dolfin-adjoint Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="../about/index.html" title="Find out more about dolfin-adjoint">About</a></li>
          <li class="page_item"><a href="../features/index.html" title="Features of dolfin-adjoint">Features</a></li>
          <li class="page_item"><a href="index.html" title="Learn how to use dolfin-adjoint">Documentation</a></li>
          <li class="page_item"><a href="../download/index.html" title="Obtain the dolfin-adjoint code">Download</a></li>
          <li class="page_item"><a href="../citing/index.html" title="Learn how to cite the dolfin-adjoint project">Citing</a></li>
          <li class="page_item"><a href="../support/index.html" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="adding-custom-functions">
<h1>Adding Custom Functions<a class="headerlink" href="#adding-custom-functions" title="Permalink to this headline">¶</a></h1>
<p>As mentioned in the <a class="reference internal" href="tutorial.html"><span class="doc">first section</span></a> of this tutorial fenics-adjoint
works by overloading parts of FEniCS so that it may build up an annotation by recording
each step of the forward model. The list of overloaded functions and objects is found
in the <a class="reference internal" href="api.html"><span class="doc">API reference</span></a>. The part of fenics-adjoint that takes care of the fundamental
annotation is pyadjoint, which is independent of FEniCS.
fenics-adjoint tells pyadjoint how to handle FEniCS types and functions.
If the forward model uses custom functions rather than the
standard FEniCS functions, pyadjoint won’t know how to record
these steps, therefore we have to tell it how, by overloading the functions ourselves.</p>
<div class="section" id="a-simple-example">
<h2>A Simple Example<a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have a module we want to use with our FEniCS model,
in this example the module will be named <code class="xref py py-data docutils literal"><span class="pre">normalise</span></code> and consist of
only one function: <code class="xref py py-data docutils literal"><span class="pre">normalise(func)</span></code>. The module looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fenics_adjoint</span> <span class="k">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">vec</span> <span class="o">/=</span> <span class="n">vec</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="s1">&#39;l2&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Function</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">function_space</span><span class="p">(),</span> <span class="n">vec</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="more info" class="align-middle" src="../_images/more.png" /> <a class="reference external" href="../_static/overloading/normalise.py">Download this file</a></p>
<p>The function <code class="xref py py-data docutils literal"><span class="pre">normalise(func)</span></code> normalises the vector form of a FEniCS function,
then returns the FEniCS function form of that normalised vector. A simple fenics
program that uses this function might look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fenics_adjoint</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">normalise</span> <span class="k">import</span> <span class="n">normalise</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;x[0]*x[1]&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">normalise</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="n">J</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="more info" class="align-middle" src="../_images/more.png" /> <a class="reference external" href="../_static/overloading/tutorial9.py">Download this example</a></p>
<p>Here we define a function on a space, normalise it with our function and integrate it
over the space. Now we want to know the gradient of <span class="math">\(J\)</span> with respect to the initial
conditions, we could try simply adding</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics_adjoint</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dJdf</span> <span class="o">=</span> <span class="n">compute_gradient</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>but that won’t work, because pyadjoint does not know that it should record
the normalisation and it does not know what the derivative of the normalisation is.
We should create a new module that overloads <code class="xref py py-data docutils literal"><span class="pre">normalise(func)</span></code>, telling
pyadjoint how to deal with it.</p>
</div>
<div class="section" id="overloading-a-function">
<h2>Overloading a function<a class="headerlink" href="#overloading-a-function" title="Permalink to this headline">¶</a></h2>
<p>Let us now create a module overloading the <code class="xref py py-data docutils literal"><span class="pre">normalise(func)</span></code> function.
We need to start by importing the FEniCS and fenics-adjoint modules, along with
some specific functions needed for overloading and of course the function we want to
overload.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fenics_adjoint</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">pyadjoint</span> <span class="kn">import</span> <span class="n">Block</span><span class="p">,</span> <span class="n">annotate_tape</span><span class="p">,</span> <span class="n">stop_annotating</span>
<span class="kn">from</span> <span class="nn">fenics_adjoint.types</span> <span class="kn">import</span> <span class="n">create_overloaded_object</span>

<span class="kn">from</span> <span class="nn">normalise</span> <span class="kn">import</span> <span class="n">normalise</span>
</pre></div>
</div>
<div class="section" id="the-overloading-function">
<h3>The overloading function<a class="headerlink" href="#the-overloading-function" title="Permalink to this headline">¶</a></h3>
<p>Since we are overloading <code class="xref py py-data docutils literal"><span class="pre">normalise(func)</span></code> we need to change it’s name
to keep acces to it:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">backend_normalise</span> <span class="o">=</span> <span class="n">normalise</span>
</pre></div>
</div>
<p>Now we are ready to write the overloaded function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
 <span class="n">annotate</span> <span class="o">=</span> <span class="n">annotate_tape</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

 <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
     <span class="n">tape</span> <span class="o">=</span> <span class="n">get_working_tape</span><span class="p">()</span>
     <span class="n">block</span> <span class="o">=</span> <span class="n">NormaliseBlock</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
     <span class="n">tape</span><span class="o">.</span><span class="n">add_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

 <span class="k">with</span> <span class="n">stop_annotating</span><span class="p">():</span>
     <span class="n">output</span> <span class="o">=</span> <span class="n">backend_normalise</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

 <span class="n">output</span> <span class="o">=</span> <span class="n">create_overloaded_object</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

 <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
     <span class="n">block</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">create_block_output</span><span class="p">())</span>

 <span class="k">return</span> <span class="n">output</span>
</pre></div>
</div>
<p>So what is going on here:</p>
<ul>
<li><p class="first">We check whether or not we should be annotating. If the user passes</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">annotate_tape</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>
</div>
<p>as a keyword argument we should treat the function call exactly as if we were just
using the non-overloaded version of  <code class="xref py py-data docutils literal"><span class="pre">normalise(func)</span></code>.</p>
</li>
<li><p class="first">If we are annotating we get the current tape, make a block, which
are the building blocks of the tape and then add the new block to the tape.
<code class="xref py py-data docutils literal"><span class="pre">NormaliseBlock(func)</span></code> is the constructor of the class
<code class="xref py py-class docutils literal"><span class="pre">NormaliseBlock(Block)</span></code>, which we will implement and which contains the
information about how pyadjoint should handle our function.</p>
</li>
<li><p class="first">We compute the normalisation with our non-overloaded function, and then make sure
that the output is an overloaded object that can be properly handled by pyadjoint.</p>
</li>
<li><p class="first">If we are annotating we add the output to our block.</p>
</li>
<li><p class="first">And finally we return the output.</p>
</li>
</ul>
<p>This is quite general, the only things that specifically refers to normalisation are
<code class="xref py py-data docutils literal"><span class="pre">backend_normalise(func)</span></code> and <code class="xref py py-data docutils literal"><span class="pre">NormaliseBlock(func)</span></code>, and the
overloading function will look very similar to this in most cases.</p>
</div>
<div class="section" id="the-block-class">
<h3>The Block class<a class="headerlink" href="#the-block-class" title="Permalink to this headline">¶</a></h3>
<p>The class <code class="xref py py-class docutils literal"><span class="pre">NormaliseBlock(Block)</span></code> is a subclass of
<a class="reference internal" href="pyadjoint_api.html#pyadjoint.Block" title="pyadjoint.Block"><code class="xref py py-class docutils literal"><span class="pre">Block</span></code></a> from the pyadjoint module. In addition to
writing a constructor we have to override the methods <code class="xref py py-meth docutils literal"><span class="pre">evaluate_adj()</span></code> and
<code class="xref py py-meth docutils literal"><span class="pre">recompute()</span></code>, we will also add a <code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code> method.
In our example the constructor may look like this</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NormaliseBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
       <span class="nb">super</span><span class="p">(</span><span class="n">NormaliseBlock</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">add_dependency</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">get_block_output</span><span class="p">())</span>
</pre></div>
</div>
<p>We call the superclass constructor and  save the key word arguments.
Then we tell pyadjoint that the operation this block represents depends
on the function <code class="xref py py-data docutils literal"><span class="pre">func</span></code>. As <code class="xref py py-data docutils literal"><span class="pre">func</span></code> should be an overloaded object it has a
<code class="xref py py-meth docutils literal"><span class="pre">get_block_output()</span></code> method.</p>
<p>Next we can define a <code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code> method. This gives a name to the block,
so the output of this is for example how the block is represented in graphs made
with <a class="reference internal" href="pyadjoint_api.html#pyadjoint.Tape.visualise" title="pyadjoint.Tape.visualise"><code class="xref py py-meth docutils literal"><span class="pre">visualise</span></code></a> as explained in the section
on <a class="reference internal" href="debugging.html"><span class="doc">debugging</span></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;NormaliseBlock&quot;</span>
</pre></div>
</div>
<p>We need a <code class="xref py py-meth docutils literal"><span class="pre">recompute</span></code> method that can
recompute the block.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recompute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">dependencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dependencies</span><span class="p">()</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">dependencies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_saved_output</span><span class="p">()</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">backend_normalise</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">=</span> <span class="n">output</span>
</pre></div>
</div>
<p>We get the inputs from the dependencies, calculate the function and save it to the ouput.</p>
</div>
<div class="section" id="the-adjoint">
<h3>The adjoint<a class="headerlink" href="#the-adjoint" title="Permalink to this headline">¶</a></h3>
<p>The method <code class="xref py py-meth docutils literal"><span class="pre">evaluate_adj()</span></code> should evaluate the adjoint gradient of the block.
In the <a class="reference internal" href="maths/index.html"><span class="doc">mathematical background</span></a> we discussed the tangent linear model
and the adjoint on the level of the whole model. Here we consider more concretely
how fenics-adjoint treats each block. pyadjoint treats a forward model as a series of equation solves.
Some of these equations are complicated PDEs that are solved by the FEniCS function <code class="xref py py-func docutils literal"><span class="pre">solve</span></code>,
but others are of the straightforward form</p>
<div class="math">
\[y = f(x_1,\ldots,x_n),\]</div>
<p>where <span class="math">\(y\)</span> is the only unknown. Our <code class="xref py py-data docutils literal"><span class="pre">normalise</span></code> function may be represented by this kind of equation.
When differentiating a functional pyadjoint works by considering each block as a link in chain formed by
the chain rule. If a functional is the result of a series of straightforward transformations on an initial condition:</p>
<div class="math">
\[J(u_n(u_{n-1}(\ldots(u_0)\ldots))),\]</div>
<p>then by the chain rule</p>
<div class="math">
\[\frac{\mathrm{d}J}{\mathrm{d}u_0} = \frac{\partial J}{\partial u_n}\frac{\partial u_n}{\partial u_{n-1}}\ldots\frac{\partial u_1}{\partial u_0}.\]</div>
<p>If we consider instead the adjoint model we will find the transpose of <span class="math">\(\frac{\mathrm{d}J}{\mathrm{d}u_0}\)</span>:</p>
<div class="math">
\[\frac{\mathrm{d}J}{\mathrm{d}u_0}^* = \frac{\partial u_1}{\partial u_0}^*\frac{\partial u_n}{\partial u_{n-1}}^*\ldots\frac{\partial J}{\partial u_n}^*.\]</div>
<p>Calculating from the right we find that for each link</p>
<div class="math">
\[y_i = \frac{\partial u_i}{\partial u_{i+1}}^*y_{i+1},\]</div>
<p>where</p>
<div class="math">
\[y_{n+1} = \frac{\partial J}{\partial u_n}.\]</div>
<p>and</p>
<div class="math">
\[y_0 = \frac{\mathrm{d} J}{\mathrm{d} u_0}\]</div>
<p>Each block only needs to find the transpose of its own gradient!
This is implemented in <code class="xref py py-meth docutils literal"><span class="pre">evaluate_adj()</span></code>.</p>
</div>
<div class="section" id="back-to-our-example">
<h3>Back to our example<a class="headerlink" href="#back-to-our-example" title="Permalink to this headline">¶</a></h3>
<p>Mathematically our normalisation block may be represented in index notation as</p>
<div class="math">
\[f(x_i) = \frac{x_i}{||x||}.\]</div>
<p>The gradient matrix is</p>
<div class="math">
\[\frac{\partial f(x_i)}{\partial x_j} = \frac{1}{||x||} \delta_{ij} - \frac{x_i x_j}{||x||^3}\]</div>
<p><code class="xref py py-meth docutils literal"><span class="pre">evaluate_adj()</span></code> takes a vector as input and returns that vector
multiplied with the transpose of the gradient:</p>
<div class="math">
\[\nabla f^* \cdot y = \sum_j \frac{\partial f(x_j)}{\partial x_i} y_j =
\sum_{j} \frac{1}{||x||} \delta_{ij} y_j -
\frac{x_i x_j}{||x||^3} y_j = \frac{y_i}{||x||} - \frac{x_i}{||x||^3} \sum_j x_j y_j\]</div>
<p>Now let us look at the implementation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">evaluate_adj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">adj_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">adj_value</span>
    <span class="n">dependency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dependencies</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">dependency</span><span class="o">.</span><span class="n">get_saved_output</span><span class="p">()</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-data docutils literal"><span class="pre">adj_input</span></code> is the vector <span class="math">\(y\)</span> above. As we are going <em>backwards</em> through the forward model
it is the output of <code class="xref py py-meth docutils literal"><span class="pre">evaluate_adj()</span></code> for the <em>output</em> of our normalisation
block. Then we get the value of the input to our block and save it as a vector.
Next, we should compute the value:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">adj_output</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">xnorm</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="s1">&#39;l2&#39;</span><span class="p">)</span>

<span class="n">const</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
    <span class="n">const</span> <span class="o">+=</span> <span class="n">adj_input</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="n">const</span> <span class="o">/=</span> <span class="n">xnorm</span><span class="o">**</span><span class="mi">3</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
    <span class="n">adj_output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj_input</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">xnorm</span> <span class="o">-</span> <span class="n">const</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally we save <code class="xref py py-data docutils literal"><span class="pre">adj_output</span></code> so that it may be propagated up the chain</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dependency</span><span class="o">.</span><span class="n">add_adj_output</span><span class="p">(</span><span class="n">adj_output</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="more info" class="align-middle" src="../_images/more.png" /> <a class="reference external" href="../_static/overloading/normalise_overloaded.py">download the overloaded module</a></p>
<p>That’s it! Now we are ready to use our function <code class="xref py py-data docutils literal"><span class="pre">normalise</span></code> with fenics-adjoint.
Let us perform a taylor test to see if it works:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fenics</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fenics_adjoint</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">normalise_overloaded</span> <span class="k">import</span> <span class="n">normalise</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;x[0]*x[1]&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">normalise</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="n">J</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>

<span class="n">h</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">h</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">taylor_test</span><span class="p">(</span><span class="n">ReducedFunctional</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Control</span><span class="p">(</span><span class="n">f</span><span class="p">)),</span> <span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="more info" class="align-middle" src="../_images/more.png" /> <a class="reference external" href="../_static/overloading/tutorial9_overloading.py">download this test</a></p>
<p>This gives the output:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Computed residuals: [5.719808547972123e-06, 1.4356712128879936e-06, 3.5963468743448646e-07, 8.999840626988198e-08]
Computed convergence rates: [1.9942414669485427, 1.997121308032896, 1.9985608192606437]
</pre></div>
</div>
<p>It works.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Sebastian Mitusch.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>